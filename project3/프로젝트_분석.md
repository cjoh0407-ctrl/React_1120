# Project3 React 일기장 앱 분석 문서

## 📌 프로젝트 개요
이 프로젝트는 React 기반의 **감정 일기장 애플리케이션**입니다. 사용자가 날짜, 감정, 일기 내용을 입력하여 일기를 작성하고, 조회, 수정, 삭제할 수 있는 기능을 제공합니다.

---

## 🗂️ 프로젝트 구조

```
src/
├── index.js              # 애플리케이션 진입점
├── App.js                # 최상위 컴포넌트, 상태 관리 및 라우팅
├── util.js               # 유틸리티 함수 모음
├── page/                 # 페이지 컴포넌트들
│   ├── Home.js           # 홈 페이지 (일기 목록)
│   ├── New.js            # 새 일기 작성 페이지
│   ├── Edit.js           # 일기 수정 페이지
│   └── Diary.js          # 일기 상세보기 페이지
├── component/            # 재사용 가능한 컴포넌트들
│   ├── Header.js         # 헤더 컴포넌트
│   ├── Button.js         # 버튼 컴포넌트
│   ├── Editor.js         # 일기 작성/수정 에디터
│   ├── DiaryList.js      # 일기 목록 표시
│   ├── DiaryItem.js      # 개별 일기 아이템
│   ├── EmotionItem.js    # 감정 선택 아이템
│   └── Viewer.js         # 일기 내용 뷰어
└── hooks/
    └── useDiary.js       # 특정 일기 조회 커스텀 훅
```

---

## 🔄 데이터 흐름 구조

### 1. 전역 상태 관리 (Context API)

#### **App.js - 중앙 상태 관리자**

```
DiaryStateContext      → 일기 데이터를 제공하는 Context
DiaryDispatchContext   → 데이터 변경 함수들을 제공하는 Context
```

**App.js의 핵심 구조:**

```javascript
// 1. useReducer로 상태 관리
const [data, dispatch] = useReducer(reducer, []);

// 2. Context로 상태와 함수 제공
<DiaryStateContext.Provider value={data}>
  <DiaryDispatchContext.Provider value={{onCreate, OnUpdate, OnDelete}}>
    {/* 모든 페이지 컴포넌트 */}
  </DiaryDispatchContext.Provider>
</DiaryStateContext.Provider>
```

#### **데이터 구조**
각 일기 데이터는 다음과 같은 형태를 가집니다:
```javascript
{
  id: "mock1",           // 고유 ID
  date: 1702123456789,   // 타임스탬프
  content: "오늘의 일기", // 일기 내용
  emotionId: 1           // 감정 ID (1~5)
}
```

---

## 🎯 핵심 함수 분석

### App.js의 주요 함수들

#### 1. **reducer 함수** - 상태 업데이트 처리
```javascript
function reducer(state, action)
```

**역할:** dispatch로 전달받은 action에 따라 상태를 업데이트합니다.

**처리하는 액션:**
- `CREATE`: 새 일기 추가 → `[새 데이터, ...기존 상태]`
- `UPDATE`: 특정 일기 수정 → `state.map()`으로 해당 id 찾아 교체
- `DELETE`: 특정 일기 삭제 → `state.filter()`로 해당 id 제외
- `INIT`: 초기 데이터 설정 → `action.data` 그대로 반환

**데이터 흐름:**
```
action → reducer 함수 → 새로운 state 반환 → data 상태 업데이트
```

---

#### 2. **onCreate 함수** - 새 일기 생성
```javascript
const onCreate = ({date, content, emotionId}) => {
  dispatch({
    type: "CREATE",
    data: {
      id: idRef.current,
      date: new Date(date).getTime(),
      content: content,
      emotionId: emotionId
    }
  });
  idRef.current += 1;
};
```

**전달 경로:**
```
App.js (onCreate 정의)
    ↓ (DiaryDispatchContext로 제공)
New.js (onCreate 가져오기)
    ↓ (onSubmit props로 전달)
Editor.js (onSubmit 실행)
    ↓ (handleSubmit 호출)
onCreate({date, content, emotionId}) 실행
    ↓
reducer의 CREATE 케이스 실행
    ↓
data 상태 업데이트
```

**매개변수:**
- `date`: 사용자가 선택한 날짜 (문자열)
- `content`: 작성한 일기 내용 (문자열)
- `emotionId`: 선택한 감정 ID (1~5)

**동작:**
1. `idRef.current`를 id로 사용
2. 날짜를 타임스탬프로 변환
3. `dispatch`로 `CREATE` 액션 전달
4. id 카운터 증가

---

#### 3. **OnUpdate 함수** - 일기 수정
```javascript
const OnUpdate = ({id, date, content, emotionId}) => {
  dispatch({
    type: "UPDATE",
    data: {
      id: id,
      date: new Date(date).getTime(),
      content,
      emotionId
    }
  });
};
```

**전달 경로:**
```
App.js (OnUpdate 정의)
    ↓ (DiaryDispatchContext로 제공)
Edit.js (OnUpdate 가져오기)
    ↓ (onClickUpdate 함수에서 호출)
Editor.js (onSubmit으로 데이터 전달)
    ↓
OnUpdate({id, date, content, emotionId}) 실행
    ↓
reducer의 UPDATE 케이스 실행
    ↓
해당 id의 일기 데이터 교체
```

**매개변수:**
- `id`: 수정할 일기의 ID
- `date`, `content`, `emotionId`: 수정된 값들

---

#### 4. **OnDelete 함수** - 일기 삭제
```javascript
const OnDelete = (targetId) => {
  dispatch({
    type: "DELETE",
    targetId
  })
}
```

**전달 경로:**
```
App.js (OnDelete 정의)
    ↓ (DiaryDispatchContext로 제공)
Edit.js (OnDelete 가져오기)
    ↓ (onClickDelete 함수에서 호출)
OnDelete(id) 실행
    ↓
reducer의 DELETE 케이스 실행
    ↓
해당 id 제외한 배열 반환
```

**매개변수:**
- `targetId`: 삭제할 일기의 ID

---

## 📄 페이지별 데이터 흐름

### 1. Home.js - 홈 페이지

**역할:** 월별 일기 목록을 표시합니다.

**데이터 흐름:**
```
DiaryStateContext에서 data 가져오기 (useContext)
    ↓
pivotDate (현재 보고 있는 년월) 상태 관리
    ↓
useEffect: data와 pivotDate 변경 감지
    ↓
getMonthRangeByDate(pivotDate) 호출
    → 해당 월의 시작/끝 타임스탬프 계산
    ↓
data.filter()로 해당 월 일기만 필터링
    ↓
setFilteredData(필터된 데이터)
    ↓
DiaryList 컴포넌트에 filteredData 전달
```

**주요 함수:**
- `onIncreaseMonth()`: pivotDate를 다음 달로 변경
- `onDecreaseMonth()`: pivotDate를 이전 달로 변경

**데이터 전달:**
```
filteredData → DiaryList 컴포넌트의 data props
```

---

### 2. New.js - 새 일기 작성 페이지

**역할:** 새로운 일기를 작성합니다.

**데이터 흐름:**
```
DiaryDispatchContext에서 onCreate 가져오기
    ↓
Editor 컴포넌트 렌더링
    ↓
사용자가 날짜, 감정, 내용 입력
    ↓
Editor의 "작성 완료" 버튼 클릭
    ↓
Editor의 handleSubmit 실행
    ↓
onSubmit(state) 호출 → New.js의 onSubmit으로 전달
    ↓
onCreate({date, content, emotionId}) 실행
    ↓
navigate("/") - 홈으로 이동
```

**onSubmit 함수:**
```javascript
const onSubmit = (data) => {
  onCreate({...data});  // Editor에서 받은 데이터를 onCreate로 전달
  navigate("/", {relative: true});  // 홈으로 이동
}
```

---

### 3. Edit.js - 일기 수정 페이지

**역할:** 기존 일기를 수정하거나 삭제합니다.

**데이터 흐름:**
```
useParams()로 URL에서 id 가져오기 (예: /edit/mock1)
    ↓
useDiary(id) 커스텀 훅 호출
    ↓
DiaryStateContext에서 data 가져오기
    ↓
data.find()로 해당 id의 일기 찾기
    ↓
찾으면: 해당 일기 데이터 반환
못 찾으면: alert 후 홈으로 이동
    ↓
Editor 컴포넌트에 initData로 전달
    ↓
사용자가 수정 후 "작성 완료" 클릭
    ↓
onClickUpdate 실행
    ↓
OnUpdate({id, date, content, emotionId}) 호출
```

**onClickUpdate 함수:**
```javascript
const onClickUpdate = (data) => {
  if(window.confirm("일기를 정말 수정할까요?")){
    OnUpdate(data);  // data에는 id도 포함됨
    navigate("/", {replace: true});
  }
}
```

**onClickDelete 함수:**
```javascript
const onClickDelete = () => {
  if(window.confirm("일기를 정말 삭제할까요?")){
    OnDelete(id);
    navigate("/", {replace: true});
  }
}
```

---

### 4. Diary.js - 일기 상세보기 페이지

**역할:** 특정 일기의 상세 내용을 표시합니다.

**데이터 흐름:**
```
useParams()로 URL에서 id 가져오기
    ↓
useDiary(id)로 해당 일기 데이터 가져오기
    ↓
data 존재 확인
    ↓
있으면: date, emotionId, content 추출
    ↓
Viewer 컴포넌트에 content와 emotionId 전달
    ↓
Viewer에서 일기 내용 표시
```

**주요 함수:**
- `goBack()`: 이전 페이지로 이동
- `goEdit()`: `/edit/${id}` 수정 페이지로 이동

---

## 🧩 컴포넌트별 데이터 흐름

### 1. Editor.js - 일기 에디터

**역할:** 일기 작성/수정 폼을 제공합니다.

**props:**
- `initData`: 수정 모드일 때 초기 데이터 (선택)
- `onSubmit`: 작성 완료 시 호출할 함수

**내부 상태:**
```javascript
const [state, setState] = useState({
  date: getFormattedDate(new Date()),  // "2024-12-09" 형식
  emotionId: 3,                        // 기본값 3
  content: ""                          // 빈 문자열
});
```

**사용자 입력 처리 함수:**

1. **handleChangeDate** - 날짜 변경
```javascript
const handleChangeDate = (e) => {
  setState({
    ...state,              // 기존 state 유지
    date: e.target.value   // 날짜만 업데이트
  });
};
```
**전달 경로:**
```
사용자가 input[type="date"] 변경
    ↓
onChange 이벤트 발생
    ↓
handleChangeDate(e) 호출
    ↓
e.target.value (선택한 날짜)
    ↓
setState로 state.date 업데이트
```

2. **handleChangeContent** - 내용 변경
```javascript
const handleChangeContent = (e) => {
  setState({
    ...state,
    content: e.target.value
  });
};
```
**전달 경로:**
```
사용자가 textarea에 입력
    ↓
onChange 이벤트 발생
    ↓
handleChangeContent(e) 호출
    ↓
e.target.value (입력한 텍스트)
    ↓
setState로 state.content 업데이트
```

3. **handleChangeEmotion** - 감정 변경
```javascript
const handleChangeEmotion = (emotionId) => {
  setState({
    ...state,
    emotionId: emotionId
  });
};
```
**전달 경로:**
```
EmotionItem 컴포넌트 클릭
    ↓
EmotionItem의 handleOnClick 실행
    ↓
onClick(id) 호출 → Editor의 handleChangeEmotion으로 전달
    ↓
emotionId 매개변수로 받음
    ↓
setState로 state.emotionId 업데이트
```

4. **handleSubmit** - 작성/수정 완료
```javascript
const handleSubmit = () => {
  onSubmit(state);  // 부모 컴포넌트로 state 전달
};
```
**전달 경로:**
```
"작성 완료" 버튼 클릭
    ↓
handleSubmit() 호출
    ↓
onSubmit(state) 실행
    ↓
New.js 또는 Edit.js의 onSubmit 함수로 state 전달
```

---

### 2. DiaryList.js - 일기 목록

**역할:** 일기 목록을 정렬하고 표시합니다.

**props:**
- `data`: 표시할 일기 배열

**내부 상태:**
```javascript
const [sortType, setSortType] = useState("latest");  // 정렬 방식
const [sortedData, setSortedData] = useState([]);    // 정렬된 데이터
```

**데이터 처리 과정:**
```
data props 받음
    ↓
useEffect: data 또는 sortType 변경 감지
    ↓
compare 함수 정의 (정렬 기준)
    - "latest": 최신순 (큰 date → 작은 date)
    - "oldest": 오래된 순 (작은 date → 큰 date)
    ↓
JSON.parse(JSON.stringify(data)) - 깊은 복사
    (원본 데이터 보존 목적)
    ↓
copyList.sort(compare) - 정렬 실행
    ↓
setSortedData(copyList) - 정렬된 데이터 저장
    ↓
sortedData.map()으로 각 일기를 DiaryItem으로 렌더링
```

**정렬 변경:**
```
<select> 요소 변경
    ↓
onChangeSortType(e) 호출
    ↓
setSortType(e.target.value)
    ↓
useEffect 재실행 (sortType 의존성)
    ↓
데이터 재정렬
```

---

### 3. DiaryItem.js - 개별 일기 아이템

**역할:** 일기 목록의 각 아이템을 표시합니다.

**props:**
- `id`: 일기 ID
- `content`: 일기 내용
- `emotionId`: 감정 ID
- `date`: 날짜 (타임스탬프)

**주요 함수:**
- `goDetail()`: `/diary/${id}` 상세보기 페이지로 이동
- `goEdit()`: `/edit/${id}` 수정 페이지로 이동

**렌더링 내용:**
```
감정 이미지 영역 (클릭 → goDetail)
    ↓
날짜: new Date(parseInt(date)).toLocaleDateString()
    ↓
내용 미리보기: content.slice(0, 25) (처음 25글자)
    ↓
"수정하기" 버튼 (클릭 → goEdit)
```

---

### 4. EmotionItem.js - 감정 선택 아이템

**역할:** 감정을 선택할 수 있는 아이템입니다.

**props:**
- `id`: 감정 ID (1~5)
- `img`: 감정 이미지
- `name`: 감정 이름
- `onClick`: 클릭 시 호출할 함수
- `isSelected`: 선택 여부 (boolean)

**클릭 처리:**
```
사용자가 EmotionItem 클릭
    ↓
handleOnClick() 실행
    ↓
onClick(id) 호출
    ↓
Editor.js의 handleChangeEmotion(id)로 전달
    ↓
Editor의 state.emotionId 업데이트
```

---

### 5. Viewer.js - 일기 뷰어

**역할:** 작성된 일기를 읽기 전용으로 표시합니다.

**props:**
- `content`: 일기 내용
- `emotionId`: 감정 ID

**데이터 처리:**
```
emotionId로 emotionList에서 해당 감정 정보 찾기
    ↓
emotionList.find((it) => it.id === emotionId)
    ↓
emotionItem.img, emotionItem.name 사용
    ↓
감정 이미지 및 이름 표시
    ↓
content 내용 그대로 표시
```

---

## 🚀 사용자 입력 시 전체 작업 순서

### 시나리오 1: 새 일기 작성

```
1. 사용자가 Home 페이지에서 "새 일기 쓰기" 버튼 클릭
   └─ DiaryList.js의 onClickNew() → navigate("/new")

2. New 페이지 렌더링
   └─ Editor 컴포넌트 표시

3. Editor 초기 상태 설정
   └─ state = {date: "오늘날짜", emotionId: 3, content: ""}

4. 사용자가 날짜 선택 (input[type="date"] 변경)
   └─ onChange 이벤트
   └─ handleChangeDate(e) 호출
   └─ setState({...state, date: e.target.value})
   └─ state.date 업데이트 → 화면 리렌더링

5. 사용자가 감정 선택 (EmotionItem 클릭)
   └─ EmotionItem onClick
   └─ handleOnClick() 실행
   └─ onClick(id) → handleChangeEmotion(id) 호출
   └─ setState({...state, emotionId: id})
   └─ state.emotionId 업데이트 → 화면 리렌더링

6. 사용자가 일기 내용 입력 (textarea에 타이핑)
   └─ onChange 이벤트 (매 글자마다)
   └─ handleChangeContent(e) 호출
   └─ setState({...state, content: e.target.value})
   └─ state.content 업데이트 → 화면 리렌더링

7. 사용자가 "작성 완료" 버튼 클릭
   └─ handleSubmit() 실행
   └─ onSubmit(state) 호출
   └─ New.js의 onSubmit(data) 실행
   └─ onCreate({...data}) 호출
   └─ App.js의 onCreate 함수 실행
   └─ dispatch({ type: "CREATE", data: {...} })
   └─ reducer 함수 실행 (CREATE 케이스)
   └─ return [action.data, ...state]
   └─ data 상태 업데이트
   └─ DiaryStateContext 값 변경
   └─ navigate("/") - 홈으로 이동

8. Home 페이지 리렌더링
   └─ useContext(DiaryStateContext)로 새 data 받음
   └─ useEffect 실행 (data 의존성 변경)
   └─ 월별 필터링 재실행
   └─ DiaryList에 새 데이터 전달
   └─ 새 일기가 목록에 표시됨
```

---

### 시나리오 2: 기존 일기 수정

```
1. 사용자가 Home 페이지에서 특정 일기의 "수정하기" 버튼 클릭
   └─ DiaryItem.js의 goEdit() → navigate(`/edit/${id}`)

2. Edit 페이지 렌더링
   └─ useParams()로 id 추출 (예: "mock1")
   └─ useDiary(id) 호출

3. useDiary 훅 실행
   └─ useContext(DiaryStateContext)로 전체 data 가져오기
   └─ useEffect 실행
   └─ data.find((it) => String(it.id) === String(id))
   └─ 일치하는 일기 찾기
   └─ 찾으면: setDiary(matchDiary) → diary 반환
   └─ 못 찾으면: alert + navigate("/")

4. Editor 컴포넌트에 initData 전달
   └─ <Editor initData={data} onSubmit={onClickUpdate} />

5. Editor 초기화
   └─ useEffect: initData 있으면 실행
   └─ setState({
        ...initData,
        date: getFormattedDate(new Date(parseInt(initData.date)))
      })
   └─ 기존 일기 데이터로 state 초기화

6. 사용자가 내용 수정 (날짜/감정/내용 변경)
   └─ 위의 "새 일기 작성" 4~6단계와 동일
   └─ handleChangeDate, handleChangeEmotion, handleChangeContent
   └─ state 업데이트

7. 사용자가 "작성 완료" 버튼 클릭
   └─ handleSubmit() 실행
   └─ onSubmit(state) 호출
   └─ Edit.js의 onClickUpdate(data) 실행
   └─ window.confirm("일기를 정말 수정할까요?")
   └─ 확인 클릭 시:
       └─ OnUpdate(data) 호출 (data에는 id 포함)
       └─ App.js의 OnUpdate 함수 실행
       └─ dispatch({ type: "UPDATE", data: {...} })
       └─ reducer 함수 실행 (UPDATE 케이스)
       └─ state.map((it) => it.id === data.id ? data : it)
       └─ 해당 id의 일기만 새 데이터로 교체
       └─ data 상태 업데이트
       └─ navigate("/", {replace: true})

8. Home 페이지 리렌더링
   └─ 수정된 일기가 목록에 반영됨
```

---

### 시나리오 3: 일기 삭제

```
1. 사용자가 Edit 페이지에서 "삭제하기" 버튼 클릭
   └─ onClickDelete() 실행

2. 삭제 확인
   └─ window.confirm("일기를 정말 삭제할까요?")
   └─ 확인 클릭 시:
       └─ OnDelete(id) 호출
       └─ App.js의 OnDelete 함수 실행
       └─ dispatch({ type: "DELETE", targetId: id })
       └─ reducer 함수 실행 (DELETE 케이스)
       └─ state.filter((it) => String(it.id) !== String(targetId))
       └─ 해당 id를 제외한 새 배열 반환
       └─ data 상태 업데이트
       └─ navigate("/", {replace: true})

3. Home 페이지 리렌더링
   └─ 삭제된 일기가 목록에서 사라짐
```

---

### 시나리오 4: 월별 일기 필터링

```
1. 사용자가 Home 페이지에서 ">" 버튼 클릭 (다음 달)
   └─ onIncreaseMonth() 호출

2. pivotDate 업데이트
   └─ setPivotDate(new Date(year, month + 1))
   └─ pivotDate 상태 변경

3. useEffect 실행 (pivotDate 의존성)
   └─ getMonthRangeByDate(pivotDate) 호출
   └─ 해당 월의 beginTimeDate, endTimeStamp 계산
       예: 2024년 12월 → 2024-12-01 00:00:00 ~ 2024-12-31 23:59:59

4. 데이터 필터링
   └─ data.filter((it) => 
        beginTimeDate <= it.date && it.date <= endTimeStamp
      )
   └─ 해당 월에 작성된 일기만 추출

5. 필터링된 데이터 저장
   └─ setFilteredData(필터된 배열)

6. DiaryList 리렌더링
   └─ <DiaryList data={filteredData} />
   └─ 해당 월의 일기만 표시됨
```

---

### 시나리오 5: 일기 정렬 변경

```
1. 사용자가 DiaryList의 <select> 드롭다운 변경
   └─ "최신순" → "오래된 순" 선택

2. 정렬 타입 변경
   └─ onChangeSortType(e) 호출
   └─ setSortType(e.target.value) → "oldest"

3. useEffect 실행 (sortType 의존성)
   └─ compare 함수 재정의
       sortType === "latest" → b.date - a.date (내림차순)
       sortType === "oldest" → a.date - b.date (오름차순)

4. 데이터 복사 및 정렬
   └─ JSON.parse(JSON.stringify(data)) - 깊은 복사
   └─ copyList.sort(compare) - 정렬 실행
   └─ setSortedData(copyList)

5. 목록 리렌더링
   └─ sortedData.map((it) => <DiaryItem {...it} />)
   └─ 새로운 순서로 일기 표시
```

---

## 🔧 유틸리티 함수 (util.js)

### 1. getEmotionImgById(emotionId)
**역할:** 감정 ID로 해당 이미지를 반환합니다.

**사용 예:**
```javascript
getEmotionImgById(1) → emotion1.png
getEmotionImgById(5) → emotion5.png
```

---

### 2. getFormattedDate(targetDate)
**역할:** Date 객체를 "YYYY-MM-DD" 형식으로 변환합니다.

**동작:**
```
new Date(2024, 11, 9) 입력
    ↓
year = 2024
month = 12 (11 + 1)
date = 9 → "09" (10보다 작으면 앞에 0 추가)
    ↓
return "2024-12-09"
```

---

### 3. emotionList
**역할:** 5가지 감정 정보 배열입니다.

**구조:**
```javascript
[
  {id: 1, name: "완전 좋음", img: emotion1.png},
  {id: 2, name: "좋음", img: emotion2.png},
  {id: 3, name: "그럭저럭", img: emotion3.png},
  {id: 4, name: "나쁨", img: emotion4.png},
  {id: 5, name: "끔찍함", img: emotion5.png}
]
```

---

### 4. getMonthRangeByDate(date)
**역할:** 특정 날짜가 속한 월의 시작/끝 타임스탬프를 반환합니다.

**동작:**
```
date = new Date(2024, 11, 15) 입력 (2024년 12월 15일)
    ↓
beginTimeDate = new Date(2024, 11, 1).getTime()
    → 2024년 12월 1일 00:00:00의 타임스탬프
    ↓
endTimeStamp = new Date(2024, 12, 0, 23, 59, 59).getTime()
    → 2024년 12월 31일 23:59:59의 타임스탬프
    ↓
return {beginTimeDate, endTimeStamp}
```

---

## 📌 핵심 개념 정리

### 1. Context API를 통한 전역 상태 관리
```
App.js에서 상태와 함수 정의
    ↓
Context Provider로 감싸기
    ↓
자식 컴포넌트들이 useContext로 접근
    ↓
props drilling 없이 데이터 공유
```

---

### 2. useReducer를 통한 복잡한 상태 관리
```
여러 액션 타입 (CREATE, UPDATE, DELETE, INIT)
    ↓
하나의 reducer 함수에서 처리
    ↓
dispatch로 액션 전달
    ↓
reducer가 새로운 상태 반환
    ↓
일관된 상태 업데이트 로직
```

---

### 3. 커스텀 훅 (useDiary)
```
특정 ID의 일기 조회 로직을 재사용
    ↓
Edit.js, Diary.js에서 동일하게 사용
    ↓
코드 중복 방지
    ↓
일기 없을 시 에러 처리까지 포함
```

---

### 4. 단방향 데이터 흐름
```
App.js (상태 보관)
    ↓ (Context로 제공)
페이지 컴포넌트 (상태 사용)
    ↓ (props로 전달)
하위 컴포넌트 (데이터 표시)
    ↓ (이벤트 발생)
콜백 함수 호출
    ↓ (dispatch)
App.js 상태 업데이트
    ↓ (리렌더링)
전체 컴포넌트 트리 업데이트
```

---

## 🎯 요약

이 프로젝트는 **React의 핵심 개념들을 활용한 일기장 애플리케이션**입니다:

1. **Context API + useReducer**로 전역 상태 관리
2. **React Router**로 페이지 라우팅
3. **커스텀 훅**으로 로직 재사용
4. **단방향 데이터 흐름**으로 예측 가능한 상태 관리
5. **컴포넌트 분리**로 재사용성과 유지보수성 향상

사용자의 모든 입력은 **state → dispatch → reducer → 새로운 state** 흐름을 따르며, Context를 통해 전체 앱에 반영됩니다.
